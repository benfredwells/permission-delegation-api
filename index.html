<!DOCTYPE html>
<head>
<meta charset="UTF-8"/>
<meta name=viewport content="width=device-width, initial-scale=1"/>
<title>Permission Delegation To Embedded Web Applications</title>

<script src='https://www.w3.org/Tools/respec/respec-w3c-common'
class='remove'></script>

<script class='remove'>
// (this is to make tidy happy)
var respecConfig = {
  specStatus:           "ED",
  shortName:            "permission-delegation",
  //publishDate:          "2016-02-17",
  //previousPublishDate:  "2016-02-17",
  //previousMaturity:     "WD",
  edDraftURI: "https://github.com/noncombatant/permission-delegation-api",
  // if this is a LCWD, uncomment and set the end of its review period
  // lcEnd: "20015-08-05",
  noIDLIn:       true,
  noLegacyStyle: true,
  editors: [
    {
      name: "Raymes Khoury",
      company: "Google Inc.",
      companyURL: "https://google.com/",
      w3cid: 45389
    },
    {
      name: "Chris Palmer",
      company: "Google Inc.",
      companyURL: "https://google.com/",
      w3cid: 45389
    }
  ],
  otherLinks: [{
    key: 'Participate',
    data: [{
              value: 'We are on Github.',
              href: 'https://github.com/noncombatant/permission-delegation-api'
          }, {
              value: 'File a bug.',
              href: 'https://github.com/noncombatant/permission-delegation-api/issues'
          }, {
              value: 'Commit history.',
              href: 'https://github.com/noncombatant/permission-delegation-api/commits/gh-pages'
          }, {
              value: 'Mailing list.',
              href: 'http://lists.w3.org/Archives/Public/public-webappsec/'
          }]
  },{
    key: 'Implementation status',
    data: [{
        value: "Blink/Chromium",
        href: "http://crbug.com/new"
    }, {
        value: "Gecko",
        href: "TODO"
    }]
  }],
  wg:           "Web Application Security Working Group",
  wgURI:        "http://www.w3.org/2011/webappsec/",
  wgPublicList: "public-webappsec",
  wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/49309/status",
};
</script>

</head>

<body>

<section id='abstract'>

This document provides a recommendation for how UAs should manage access to
permissions in cross-origin, embedded applications. Namely, it is recommended
that UAs only allow permissions to be given to embedded applications via
delegation from the embedding application.

A web platform API for delegating permissions to embedded applications is also
described. This API allows a web application to explicitly delegate and
un-delegate permissions that it holds to cross-origin embedded applications. It
also allows a web application to query the status of delegation to an embedded
application.

</section>

<section id='sotd'></section>

<section id='conformance'>

<p>This specification defines conformance criteria that apply to a single
product: the <dfn>user agent</dfn> that implements the interfaces that it
contains.</p>

<p>Implementations that use ECMAScript to expose the APIs defined in this
specification MUST implement them in a manner consistent with the ECMAScript
Bindings defined in the Web IDL specification [[!WEBIDL]].</p>

</section>

<section>

<h2>Dependencies</h2>

<p>The following concepts and interfaces are defined in [[!HTML]]:</p>

<ul>

<li><a
href='https://html.spec.whatwg.org/multipage/browsers.html#origin-2'><dfn>origin</dfn></a>
of a <a
href='https://html.spec.whatwg.org/multipage/dom.html#document'><dfn>Document</dfn></a>
and a <a
href='https://html.spec.whatwg.org/multipage/workers.html#workers'><dfn>worker</dfn></a>.</li>

<li><dfn><a
href="https://html.spec.whatwg.org/multipage/webappapis.html#queue-a-task">queue
a task</a></dfn></li>

<li><dfn><a
href="https://html.spec.whatwg.org/multipage/webappapis.html#fire-a-simple-event">fire
a simple event</a></dfn></li>

<li><dfn><a
href="https://html.spec.whatwg.org/multipage/webappapis.html#event-handlers">event
handler</a></dfn></li>

<li><dfn><a
href="https://html.spec.whatwg.org/multipage/webappapis.html#event-handler-event-type">event
handler event type</a></dfn></li>

<li><dfn><a
href='https://html.spec.whatwg.org/multipage/browsers.html#window'>Window</a></dfn></li>

<li><dfn><a
href='https://html.spec.whatwg.org/multipage/webappapis.html#global-object'>global
object</a></dfn></li>

<li><dfn><a href='https://html.spec.whatwg.org/multipage/embedded-content.html#the-iframe-element'>iframe
element</a></dfn></li>

</ul>

<p><a
href='http://people.mozilla.org/~jorendorff/es6-draft.html#sec-promise-objects'>
<dfn>Promise</dfn> objects</a> are defined in [[!ECMASCRIPT]].</p>

</section>

<section>

<h2>Definitions</h2>

TODO: define embedder, embedee, delegate, undelegate?

</section>

<section class='informative'>

<h2>Background and Motivations</h2>

<p>Web applications are able to request permissions, such as geolocation, using
various APIs on the web platform. In many UAs these permission requests will
trigger prompts to the user to make a decision about whether to allow access to
the permission to the requesting origin. In many UAs these user decisions will
also be persisted, such that the user will not have to make a decision for
subsequent access requests.</p>

<p>Web applications are composable: one web application (known as the
<dfn>embedder</dfn>) can embed others: (known as <dfn>embedees</dfn>) by using
the iframe HTML tag. If a cross-origin embedee request permissions, it can be
problematic from the perspective of both the user and the embedder. There are 4
reasons for this:
<ol>
  <li>
    User's don't have a good understanding of permission requests from
    embedees. There is often no UA UI that identifies iframes or what origin
    is running. They may even be invisible on a page. The concept of
    composable applications is not a simple one to convey. The results of a user
    study showed that participants were generally confused about who they were
    granting access to when a permission request was coming from an embedee.
  </li>
  <li>
    It's unclear how to persist decisions made about embedees. Different UAs
    persist user decisions about embedees in different ways. Some use the
    combination of the top-level web application's origin and the embedee's
    origin to store the decision, such that the decision is only remembered in
    the context of the top level web application. Others only use the requesting
    origin. There are trade-offs here, for example if only the requesting origin
    is used, the user may be surprised that a decision about a top level web
    application has also applied when that same origin is embedded on other
    sites. The inconsistency across UAs also makes behavior hard for users to
    predict.
  </li>
  <li>
    It's difficult to build understandable permission management UI. This is
    particularly true if UAs persist decisions to a combination of the top-level
    web application's origin and the embedee's origin. UI surfaces such as
    revocation and auditing UI need to be able to deal with displaying two
    origins in a way that the user can understand.
  </li>
  <li>
    Embedders have no way to regulate access to their embedees. This means that
    embedees can behave in ways that reflect badly on the embedder.
  </li>
</ol>
</p>

<p>In order to attempt to address these issues, this document recommends that
UAs require embedders to delegate permissions to embedees in order for them to
gain access. Delegation (in the context of this document) is the ability for an
origin running in one frame to share a permission grant with an embedded,
cross-origin frame without burdening the user with a need to give consent. Users
would only ever be required to make permission decisions about top-level web
applications: the one they are viewing on the page. The benefits of this, with
relation to the above problems are:
<ol>
  <li>
    The user does not need to understand the nature of composable web
    applications because they only ever make decisions about the top-level
    web application.
  </li>
  <li>
    It is clear how to persist user decisions: they are only ever stored for the
    top level web application.
  </li>
  <li>
    Because decisions are only ever made about the top level web application, it
    is much easier to build permission management UI.
  </li>
  <li>
    Because embedees cannot gain access on their own, embedders are able to
    police their embedders.
  </li>
</ol>
</p>

<p>Note that there is an implicit trade-off with delegation. Although the user
is not burdened with the decision, it also means that control is taken out of
their hands. A discussion of this tradeoff is given in the section on Security
Considerations.</p>

<p>Delegation of permissions is already possible on the web platform. For
example, if an origin in a frame has been granted access to use geolocation, it
can expose access to the feature to other, cross-origin frames by communicating
via postMessage. This document describes a new web platform API to facilitate
delegation in a standard way. This would make it much easier and more efficient
to delegate access and in a way that is still under the control of the UA. In
addition to delegating access, the ability to revoke delegated access and query
it's status is also exposed in the API.</p>

</section>

<section>

<h2>Permission Restrictions for Embedded Web Applications</h2>

<p>Cross-origin embedded applications SHOULD only be able to acquire permission
grants by explicit delegation from the embedder using the API described in the
section below. In cases where an embedder has chosen not to delegate a
permission, the embedee SHOULD NOT be able to trigger permission prompts to the
user and the embedee SHOULD NOT be able to acquire permission based on a prior
decision made by the user.</p>

<p>UAs MAY allow cross-origin embedded applications to acquire permission grants
through the use of advanced user configurations, such as custom whitelists.</p>

<p>The above requirements do not apply to permissions that are granted to
service workers as these can trivially be accessed from embedded
applications.</p>

</section>

<section>

<h2>Delegating Permissions</h2>

<p>There are 2 ways for an embedder to delegate permission grants to an embedee:
A declarative syntax in the HTML tag that instantiates the embedee; and an
imperative syntax that extends the Permissions API. These are described
below.</p>

<p>Once a permission has been delegated to an embedee, the embedee must have
access to use the permission as long as the following requirements are met:
  <ol>
    <li>The embedder and embedee meet the minimum security requirements to ask
    for the permission in the first place. Currently this requires that both
    embedder and embedee be running in
    <a href="http://www.w3.org/TR/powerful-features/">secure contexts</a>.</li>
    <li>The embedder itself has access to the permission.</li>
  </ol>
</p>

<p>The lifetime of the embedees access to the permission must be tied to the
lifetime of the embedders access to the permission. That is, the embedee will
only get access to the permission when the embedder has access and will lose
access if the embedder loses access.</p>

<p>Note that an embedder must still be able to ask for a permission to be
delegated even before it has access to use the permission itself. In cases like
this, a request to use the permission by the embedee may trigger an automatic
request to use the permission by the embedder. This allows embedees to get
access to permissions without embedders having to get access up front.</p>

<p>If an embedee performs a cross-origin navigation the permission must be
implicitly un-delegated and the embedee will lose access. This prevents
unintentionally delegating access to other origins.</p>

<section>

<h3>Delegation via the Declarative API</h3>

The permissions attribute is defined on the <a>iframe element<a>.

<pre class='idl'>
interface HTMLIFrameElement : HTMLElement {
  [PutForwards=value] readonly attribute DOMSettableTokenList permission;
};
</pre>

<p>The permissions attribute, when specified, will delegate the given set of
permissions to the embedee running in the iframe. Its value must be an unordered
set of unique space-separated tokens that are ASCII case-insensitive. The
allowed values are the permission names that come from the <a
href="https://w3c.github.io/permissions/#permission-registry">PermissionName</a>
enum in the Permissions API.</p>

</section>

<section>

<h3>Delegation via the Imperative API</h3>

The Permissions API is extended to provide functions for delegating and
undelegating permissions as well as querying the delegation status.

<pre class='idl'>
  [Exposed=(Window,Worker)]
  interface Permissions {
    Promise delegate((PermissionDescriptor or sequence&lt;PermissionDescriptor&gt;) permission);
    Promise undelegate((PermissionDescriptor or sequence&lt;PermissionDescriptor&gt;) permission);
    Promise&lt;boolean&gt; isDelegated(PermissionDescriptor permission);
  };
</pre>

PermissionDescriptor is defined in the Permission API. When called with these
functions it must contain a field which specifies the embedee:

<dl class='idl' title='dictionary PermissionDescriptor'>
  <dt>
    required PermissionName <a>name</a>
  </dt>
  <dt>
    HTMLIframeElement embedee
  </dt>
</dl>

<p>The embedee must be nested in the caller's browsing context.</p>

<p>Calling delegate will cause the given permissions to be delegated to their
embedees. The promise returned will resolve if the permission is successfully
delegated, otherwise it will be rejected. Similarly, undelegate will cause the
given permissions to no longer be delegated to their embedees.</p>

<p>The isDelegated function returns a promise which will resolve to true if the
permission is delegated to the given frame or to false otherwise.</p>

</section>

</section>

<section>

<h2>Examples</h2>

<p>Consider an embedder https://restaurant.example.net whose developers want to
show a map on the page that enables people to get directions to the restaurant.
They can do so by instantiating an iframe to the maps service
https://maps.example.com, and by explicitly delegating the
<var>geolocation</var> permission:

<pre class='example highlight'>
&lt;iframe id="embedee" src="https://maps.example.com/" permissions="geolocation"&gt;&lt;/iframe&gt;
</pre>

<p>Consider next that the developers of https://restaurant.example.net learn of
a new feature that https://maps.example.com provides, which is to send people
notifications when it’s time to leave to get to their destination on time.
(For example, people may want to know not just the directions to the restaurant,
but also to be notified when they should leave to make it by the time their
reservation starts.) The developers would explicitly grant the embedded iframe a
second permission, <var>notifications</var>:</p>

<pre class='example highlight'>
&lt;iframe id="embedee" src="https://maps.example.com/" permissions="geolocation notifications"&gt;&lt;/iframe&gt;
</pre>

Delegation via the imperative API:

<pre class='example highlight'>
var iframe = document.getElementById('embedee');
navigator.permissions.delegate({embedee: iframe, name: 'geolocation'}).then(
  function() {
    // Delegated geolocation
  }).catch(function() {
    // Did not delegate geolocation
  });
</pre>

Undelegating permissions:

<pre class='example highlight'>
var iframe = document.getElementById('embedee');
navigator.permissions.undelegate({embedee: iframe, name: 'geolocation'});
</pre>

Checking whether permission is delegated:

<pre class='example highlight'>
var iframe = document.getElementById('embedee');
navigator.permissions.isDelegated({embedee: iframe, name: 'geolocation'})
  .then(function(result) {
    // result === true
  });
</pre>

</section>

<section>

<h2>Security Considerations</h2>

TODO: expand this to argue the transfer of the trust decision from the user to
the embedder and tie into the section below.

<h3>Breaks Principle Of Least Privilege</h3>

<p>The obvious downside of this proposal is that an iframe can’t get access to a
permission without the top level frame also getting access to the permission.
For example, currently when purchasing an airline ticket on the British Airways
website with an AMEX credit card, an iframe navigated to the AMEX site may ask
for your location in order to verify your purchase. Under this proposal, the
user would have to give access to their location to British Airways as well as
AMEX instead of just AMEX. Note that the decision would only be persisted for
British Airways.</p>

<p>We could extend this scenario to a potentially more problematic case where a
less trustworthy site, such as https://suspicious.com also allows purchases and
embeds an AMEX frame for credit card verification. Now the user has to give
access to their location to https://suspicious.com as well as AMEX to complete
their purchase which obviously is not ideal. </p>

<p>On the flip side, in the current situation where iframes are allowed to
request location directly, https://suspicious.com can pretend to embed AMEX and
try to phish the user’s location access (note that there may be other ways to
mitigate this risk as well).</p>

</section>

<section>

<h2>Other Risks</h2>

<h3>Breaks Legacy Applications</h3>

<p>Web apps that currently utilise iframes that request permissions will be
broken by this proposal. In order to restore functionality, website owners will
need to change their &lt;iframe&gt; tags to specify which permissions they wish
to delegate. We have given more detail about the nature of this breakage in the
section below on compatibility risk. In particular the usage of permission
features in iframes is already very low on the web, meaning the impact should be
small.</p>

<p>The upside of this breakage is that any harmful/annoying permission requests
from third party iframes, which website owners did not intend their users to be
exposed to will be prevented.</p>

<p>Furthermore, this proposal would cause secure (HTTPS) iframes embedded in
non-secure (HTTP) sites to no longer be capable of getting access to
permissions. The reason is that the availability of “powerful features” on
non-secure origins is being phased out (see the Secure Contexts spec). This
means that a top level HTTP site would never be able to access a permission in
order to delegate it. This is actually not more restrictive than what is
specified in the Secure Contexts spec, which requires all ancestor frames be
secure in order for a frame to be considered secure (see the section on
Ancestral Risk). So this proposal would not result in additional breakages
compared with what is planned to be implemented in that specification.</p>

<h3>Changing iframe Permissions</h3>

<p>Another, longer-term downside is that it is hard to change permissions on
&lt;iframe&gt; tags that have already been deployed. This is made worse by the
fact that iframes tend to be fairly widely copy/pasted. For example, to make it
easy for developers to embed YouTube videos, YouTube provides a HTML
&lt;iframe&gt; snippet which can be pasted into a website. If the permissions
required to run YouTube ever changed, it would be impossible for YouTube to
update all the users. In some ways this could be considered a good thing, as
first party website owners would explicitly have to decide whether to allow an
iframe to get access to a permission.</p>


</section>

<section>

<h2>Acknowledgements</h2>

TODO
</section>

</body>
